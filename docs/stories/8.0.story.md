# Story 8.0: Enhanced Map View with Multi-Listing Support

## Story Overview
- **Story ID:** STORY-8.0
- **Priority:** High
- **Estimated Points:** 13
- **Sprint:** TBD
- **Dependencies:** Existing map implementation, search functionality, database listings

## User Story
**As a** property seeker or landlord  
**I want to** view and interact with multiple property listings on an enhanced map interface  
**So that** I can efficiently explore properties in specific locations, handle multiple listings at the same address, and make informed decisions based on geographic distribution and clustering

## User Personas & Needs

### Primary Personas:
1. **Commercial Property Occupier** (Business requiring space)
   - Needs to see all available properties in target locations
   - Wants to understand property density in specific areas
   - Requires efficient navigation between multiple listings at same location
   - Values quick access to detailed property information

2. **Property Landlord/Agent** (Property provider)
   - Needs to see competition and market density
   - Wants to understand geographic distribution of demand
   - Requires efficient browsing of multiple listings
   - Values responsive mobile experience for on-the-go usage

3. **Property Search Consultant** (Professional researcher)
   - Needs comprehensive view of market availability
   - Wants to analyze geographic patterns and clusters
   - Requires efficient multi-listing comparison
   - Values detailed filtering and search capabilities

## Business Value & Success Metrics

### Business Value:
- **Enhanced User Experience**: Improved map interaction reduces search friction
- **Increased Engagement**: Multi-listing support encourages deeper exploration
- **Better Conversion**: Location-based navigation improves property inquiry rates
- **Mobile Optimization**: Enhanced mobile experience captures growing mobile user base
- **Data Utilization**: Real database integration provides accurate, current information

### Success Metrics:
- **Map Interaction**: 40% increase in map zoom/pan interactions
- **Listing Views**: 25% increase in property detail page visits from map
- **Mobile Usage**: 35% improvement in mobile map engagement metrics
- **Multi-Listing Interaction**: >60% of users interact with count badges when present
- **Search Conversion**: 20% increase in searches leading to contact forms

## Acceptance Criteria

### AC1: Multi-Listing Count Badges and Clustering
- **GIVEN** multiple property listings exist at the same geographic location
- **WHEN** a user views the map
- **THEN** they should see:
  - Single marker with count badge showing number of listings (e.g., "3")
  - Count badge styled with vibrant color and clear typography
  - Visual distinction between single listings (no badge) and multi-listings (with badge)
  - Consistent marker clustering based on zoom level and geographic proximity
  - Smooth transitions when zooming in/out affects clustering

#### Design Specifications:
```scss
.map-marker {
  position: relative;
  background: #8B5CF6;
  border: 3px solid white;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
  cursor: pointer;
  transition: all 0.3s ease;

  &:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
    z-index: 1000;
  }

  &--multi-listing {
    background: #F97316;
    border-color: white;
  }

  &__count-badge {
    position: absolute;
    top: -8px;
    right: -8px;
    background: #DC2626;
    color: white;
    border-radius: 50%;
    min-width: 20px;
    height: 20px;
    font-size: 12px;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid white;
    box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3);
  }

  @media (max-width: 768px) {
    width: 44px;
    height: 44px;

    &__count-badge {
      min-width: 24px;
      height: 24px;
      font-size: 14px;
      top: -6px;
      right: -6px;
    }
  }
}
```

### AC2: Multi-Select Popup Interface
- **GIVEN** a user clicks on a marker with multiple listings
- **WHEN** the popup opens
- **THEN** they should see:
  - List of all properties at that location
  - Each listing shows: property type, size, price, availability status
  - Individual "View Details" buttons for each listing
  - "Select All" functionality for comparison purposes
  - Responsive layout optimized for both desktop and mobile
  - Quick action buttons: "Contact All", "Save All", "Compare"

#### Design Specifications:
```scss
.map-popup {
  background: white;
  border-radius: 16px;
  box-shadow: 0 16px 48px rgba(0, 0, 0, 0.15);
  max-width: 400px;
  min-width: 320px;
  overflow: hidden;
  border: 1px solid #E5E7EB;

  &__header {
    padding: 20px;
    background: linear-gradient(135deg, #F8FAFC 0%, #F1F5F9 100%);
    border-bottom: 1px solid #E5E7EB;

    &-title {
      font-size: 18px;
      font-weight: 700;
      color: #1F2937;
      margin-bottom: 4px;
    }

    &-address {
      font-size: 14px;
      color: #6B7280;
    }

    &-count {
      display: inline-block;
      background: #8B5CF6;
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 600;
      margin-top: 8px;
    }
  }

  &__listings {
    max-height: 300px;
    overflow-y: auto;
  }

  &__listing {
    padding: 16px 20px;
    border-bottom: 1px solid #F3F4F6;
    transition: background-color 0.2s ease;

    &:hover {
      background: #F9FAFB;
    }

    &:last-child {
      border-bottom: none;
    }

    &--selected {
      background: rgba(139, 92, 246, 0.05);
      border-left: 4px solid #8B5CF6;
    }
  }

  &__listing-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 8px;
  }

  &__listing-title {
    font-size: 16px;
    font-weight: 600;
    color: #1F2937;
    margin: 0;
  }

  &__listing-type {
    background: #F3F4F6;
    color: #6B7280;
    padding: 2px 8px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 500;
  }

  &__listing-details {
    display: flex;
    gap: 16px;
    margin-bottom: 12px;
    font-size: 14px;
    color: #6B7280;
  }

  &__listing-detail {
    display: flex;
    align-items: center;
    gap: 4px;

    svg {
      width: 16px;
      height: 16px;
    }
  }

  &__listing-price {
    font-size: 16px;
    font-weight: 700;
    color: #059669;
    margin-bottom: 12px;
  }

  &__listing-actions {
    display: flex;
    gap: 8px;
  }

  &__button {
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;

    &--primary {
      background: #8B5CF6;
      color: white;

      &:hover {
        background: #7C3AED;
      }
    }

    &--secondary {
      background: #F3F4F6;
      color: #6B7280;

      &:hover {
        background: #E5E7EB;
        color: #374151;
      }
    }

    &--select {
      background: transparent;
      color: #8B5CF6;
      border: 1px solid #8B5CF6;

      &:hover {
        background: rgba(139, 92, 246, 0.1);
      }

      &--selected {
        background: #8B5CF6;
        color: white;
      }
    }
  }

  &__footer {
    padding: 16px 20px;
    background: #F9FAFB;
    border-top: 1px solid #E5E7EB;
  }

  &__bulk-actions {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }

  &__select-all {
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    color: #6B7280;

    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
  }

  @media (max-width: 768px) {
    max-width: 95vw;
    min-width: 280px;

    &__listing-details {
      flex-direction: column;
      gap: 8px;
    }

    &__listing-actions,
    &__bulk-actions {
      flex-direction: column;
    }

    &__button {
      width: 100%;
      justify-content: center;
    }
  }
}
```

### AC3: Real Database Integration
- **GIVEN** the map loads property data
- **WHEN** listings are displayed
- **THEN** they should:
  - Display real property data from the database
  - Show accurate availability status and last updated timestamps
  - Include all relevant property details (size, type, price, features)
  - Update in real-time when new listings are added/modified
  - Handle data loading states with appropriate skeletons/spinners
  - Display "No listings found" states appropriately

#### API Endpoint Enhancement:
```typescript
// Enhanced API endpoint for map listings
interface MapListingRequest {
  bounds: {
    north: number;
    south: number;
    east: number;
    west: number;
  };
  filters?: {
    propertyType?: string[];
    sizeMin?: number;
    sizeMax?: number;
    priceMin?: number;
    priceMax?: number;
    availability?: 'available' | 'under_offer' | 'all';
  };
  clustering?: {
    enabled: boolean;
    minZoom: number;
    maxDistance: number;
  };
}

interface MapListingResponse {
  listings: Array<{
    id: string;
    title: string;
    address: {
      street: string;
      city: string;
      postcode: string;
      coordinates: {
        lat: number;
        lng: number;
      };
    };
    property: {
      type: string;
      size: number;
      sizeUnit: 'sqft' | 'sqm';
      price: number;
      priceUnit: 'month' | 'year' | 'psf';
      availability: 'available' | 'under_offer' | 'let';
      features: string[];
    };
    contact: {
      name: string;
      phone?: string;
      email: string;
    };
    updatedAt: string;
    images?: string[];
  }>;
  clusters: Array<{
    coordinates: {
      lat: number;
      lng: number;
    };
    count: number;
    listingIds: string[];
    bounds: {
      north: number;
      south: number;
      east: number;
      west: number;
    };
  }>;
  totalCount: number;
  hasMore: boolean;
}
```

### AC4: Location-Based Navigation and Search Integration
- **GIVEN** a user enters a location in the search input
- **WHEN** they perform a search
- **THEN** the map should:
  - Automatically pan and zoom to the searched location
  - Highlight the search area with a subtle overlay
  - Load and display relevant listings in the viewport
  - Update the URL to reflect the current map state
  - Provide search suggestions as user types
  - Handle invalid/not found locations gracefully

#### Implementation Specifications:
```typescript
interface LocationSearchService {
  // Geocoding service integration
  geocodeLocation(query: string): Promise<{
    address: string;
    coordinates: { lat: number; lng: number };
    bounds?: {
      north: number;
      south: number;
      east: number;
      west: number;
    };
    confidence: number;
  }>;

  // Reverse geocoding for map interactions
  reverseGeocode(lat: number, lng: number): Promise<{
    address: string;
    components: {
      street?: string;
      city?: string;
      postcode?: string;
      country?: string;
    };
  }>;

  // Location suggestions
  getSuggestions(query: string): Promise<Array<{
    address: string;
    coordinates: { lat: number; lng: number };
    type: 'address' | 'city' | 'postcode' | 'area';
  }>>;
}

// Map state management
interface MapState {
  center: { lat: number; lng: number };
  zoom: number;
  bounds: {
    north: number;
    south: number;
    east: number;
    west: number;
  };
  searchQuery?: string;
  selectedListings: string[];
  filters: PropertyFilters;
}

// URL state synchronization
const useMapURL = () => {
  const updateURL = (state: MapState) => {
    const params = new URLSearchParams();
    params.set('lat', state.center.lat.toString());
    params.set('lng', state.center.lng.toString());
    params.set('zoom', state.zoom.toString());
    if (state.searchQuery) params.set('q', state.searchQuery);
    
    window.history.replaceState({}, '', `${window.location.pathname}?${params}`);
  };
  
  const getStateFromURL = (): Partial<MapState> => {
    const params = new URLSearchParams(window.location.search);
    return {
      center: {
        lat: parseFloat(params.get('lat') || '51.5074'),
        lng: parseFloat(params.get('lng') || '-0.1278')
      },
      zoom: parseInt(params.get('zoom') || '12'),
      searchQuery: params.get('q') || undefined
    };
  };
  
  return { updateURL, getStateFromURL };
};
```

### AC5: Enhanced Mobile Support and Touch Optimization
- **GIVEN** a user accesses the map on a mobile device
- **WHEN** they interact with map elements
- **THEN** they should experience:
  - Touch targets minimum 44x44px for all interactive elements
  - Smooth touch gestures for pan, zoom, and marker selection
  - Optimized popup layouts that don't obstruct map view
  - Touch-friendly multi-select interactions
  - Responsive popup sizing based on screen size
  - Accessible zoom controls and map navigation

#### Mobile Optimization Specifications:
```scss
.map-container {
  position: relative;
  width: 100%;
  height: 100%;
  touch-action: manipulation;

  @media (max-width: 768px) {
    &__controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1000;
    }

    &__control-button {
      width: 44px;
      height: 44px;
      background: white;
      border: 1px solid #E5E7EB;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      cursor: pointer;
      touch-action: manipulation;

      &:active {
        transform: scale(0.95);
      }

      svg {
        width: 20px;
        height: 20px;
        color: #6B7280;
      }
    }

    &__search {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      z-index: 1000;
    }

    &__search-input {
      width: 100%;
      height: 48px;
      padding: 0 16px;
      border: 1px solid #E5E7EB;
      border-radius: 12px;
      background: white;
      font-size: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);

      &:focus {
        outline: none;
        border-color: #8B5CF6;
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.25);
      }
    }
  }
}

// Touch-optimized popup positioning
.map-popup {
  @media (max-width: 768px) {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    max-width: none;
    max-height: 60vh;
    border-radius: 16px 16px 0 0;
    transform: translateY(0);
    transition: transform 0.3s ease;

    &--hidden {
      transform: translateY(100%);
    }

    &__drag-handle {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 40px;
      height: 4px;
      background: #D1D5DB;
      border-radius: 2px;
    }

    &__header {
      padding-top: 28px;
    }
  }
}
```

### AC6: Performance and Loading States
- **GIVEN** the map is loading data or processing interactions
- **WHEN** users are waiting for content
- **THEN** they should see:
  - Skeleton loading states for listings
  - Progressive loading of map markers as data arrives
  - Smooth transitions between loading and loaded states
  - Error states with retry options
  - Optimized clustering algorithms for large datasets
  - Debounced search input to reduce API calls

#### Performance Implementation:
```typescript
// Optimized marker clustering
class MapClusterManager {
  private clusters: Map<string, ClusterGroup> = new Map();
  private readonly minZoom = 10;
  private readonly maxDistance = 50;

  updateClusters(listings: MapListing[], zoom: number, bounds: MapBounds) {
    if (zoom >= this.minZoom) {
      return this.createClusters(listings, bounds);
    }
    return listings.map(listing => ({
      type: 'single' as const,
      listing,
      coordinates: listing.coordinates
    }));
  }

  private createClusters(listings: MapListing[], bounds: MapBounds) {
    const clusters: ClusterGroup[] = [];
    const processed = new Set<string>();

    for (const listing of listings) {
      if (processed.has(listing.id)) continue;

      const nearby = this.findNearbyListings(
        listing,
        listings.filter(l => !processed.has(l.id)),
        this.maxDistance
      );

      if (nearby.length > 1) {
        clusters.push({
          type: 'cluster',
          listings: nearby,
          coordinates: this.calculateCenterPoint(nearby),
          count: nearby.length
        });
        nearby.forEach(l => processed.add(l.id));
      } else {
        clusters.push({
          type: 'single',
          listing,
          coordinates: listing.coordinates
        });
        processed.add(listing.id);
      }
    }

    return clusters;
  }

  private findNearbyListings(
    center: MapListing,
    candidates: MapListing[],
    maxDistance: number
  ): MapListing[] {
    return candidates.filter(listing => {
      const distance = this.calculateDistance(
        center.coordinates,
        listing.coordinates
      );
      return distance <= maxDistance;
    });
  }

  private calculateDistance(
    point1: { lat: number; lng: number },
    point2: { lat: number; lng: number }
  ): number {
    const R = 6371e3; // Earth's radius in meters
    const φ1 = point1.lat * Math.PI/180;
    const φ2 = point2.lat * Math.PI/180;
    const Δφ = (point2.lat-point1.lat) * Math.PI/180;
    const Δλ = (point2.lng-point1.lng) * Math.PI/180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
              Math.cos(φ1) * Math.cos(φ2) *
              Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c;
  }

  private calculateCenterPoint(listings: MapListing[]): { lat: number; lng: number } {
    const totalLat = listings.reduce((sum, l) => sum + l.coordinates.lat, 0);
    const totalLng = listings.reduce((sum, l) => sum + l.coordinates.lng, 0);
    
    return {
      lat: totalLat / listings.length,
      lng: totalLng / listings.length
    };
  }
}

// Loading state management
interface LoadingStates {
  mapLoading: boolean;
  listingsLoading: boolean;
  searchLoading: boolean;
  error: string | null;
}

const useMapLoadingStates = () => {
  const [states, setStates] = useState<LoadingStates>({
    mapLoading: true,
    listingsLoading: false,
    searchLoading: false,
    error: null
  });

  const setMapLoading = (loading: boolean) =>
    setStates(prev => ({ ...prev, mapLoading: loading }));

  const setListingsLoading = (loading: boolean) =>
    setStates(prev => ({ ...prev, listingsLoading: loading }));

  const setSearchLoading = (loading: boolean) =>
    setStates(prev => ({ ...prev, searchLoading: loading }));

  const setError = (error: string | null) =>
    setStates(prev => ({ ...prev, error }));

  return {
    states,
    setMapLoading,
    setListingsLoading,
    setSearchLoading,
    setError
  };
};
```

## Technical Implementation Details

### Component Architecture:
```
src/components/map/
├── MapContainer.tsx (main container)
├── MapView.tsx (map rendering)
├── MapMarker.tsx (individual markers)
├── MapCluster.tsx (cluster markers)
├── MapPopup.tsx (listing popup)
├── MapControls.tsx (zoom, search controls)
├── MapSearch.tsx (location search)
├── LoadingStates.tsx (skeletons and spinners)
└── hooks/
    ├── useMapData.ts (data fetching)
    ├── useMapClustering.ts (clustering logic)
    ├── useMapSearch.ts (search integration)
    └── useMapURL.ts (URL state sync)
```

### Database Query Enhancements:
```sql
-- Optimized spatial query for map bounds
SELECT 
  l.id,
  l.title,
  l.property_type,
  l.size_sqft,
  l.price_per_month,
  l.availability_status,
  l.updated_at,
  ST_X(l.coordinates) as longitude,
  ST_Y(l.coordinates) as latitude,
  a.street_address,
  a.city,
  a.postcode,
  c.name as contact_name,
  c.email as contact_email,
  c.phone as contact_phone,
  array_agg(DISTINCT f.feature_name) as features,
  array_agg(DISTINCT i.image_url) as images
FROM listings l
JOIN addresses a ON l.address_id = a.id
JOIN contacts c ON l.contact_id = c.id
LEFT JOIN listing_features lf ON l.id = lf.listing_id
LEFT JOIN features f ON lf.feature_id = f.id
LEFT JOIN listing_images i ON l.id = i.listing_id
WHERE 
  l.status = 'active'
  AND l.coordinates && ST_MakeEnvelope($1, $2, $3, $4, 4326)
  AND ($5::text IS NULL OR l.property_type = ANY($5::text[]))
  AND ($6::integer IS NULL OR l.size_sqft >= $6)
  AND ($7::integer IS NULL OR l.size_sqft <= $7)
  AND ($8::integer IS NULL OR l.price_per_month >= $8)
  AND ($9::integer IS NULL OR l.price_per_month <= $9)
  AND ($10::text IS NULL OR l.availability_status = $10)
GROUP BY 
  l.id, l.title, l.property_type, l.size_sqft, l.price_per_month,
  l.availability_status, l.updated_at, l.coordinates,
  a.street_address, a.city, a.postcode,
  c.name, c.email, c.phone
ORDER BY l.updated_at DESC
LIMIT 200;

-- Index optimization for spatial queries
CREATE INDEX CONCURRENTLY idx_listings_coordinates_gist 
ON listings USING GIST (coordinates);

CREATE INDEX CONCURRENTLY idx_listings_bounds_search 
ON listings (status, property_type, size_sqft, price_per_month, availability_status)
WHERE status = 'active';
```

### API Endpoint Implementation:
```typescript
// Enhanced map listings endpoint
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    
    // Parse bounds
    const bounds = {
      north: parseFloat(searchParams.get('north') || '0'),
      south: parseFloat(searchParams.get('south') || '0'),
      east: parseFloat(searchParams.get('east') || '0'),
      west: parseFloat(searchParams.get('west') || '0')
    };

    // Parse filters
    const filters = {
      propertyType: searchParams.get('propertyType')?.split(','),
      sizeMin: searchParams.get('sizeMin') ? parseInt(searchParams.get('sizeMin')!) : undefined,
      sizeMax: searchParams.get('sizeMax') ? parseInt(searchParams.get('sizeMax')!) : undefined,
      priceMin: searchParams.get('priceMin') ? parseInt(searchParams.get('priceMin')!) : undefined,
      priceMax: searchParams.get('priceMax') ? parseInt(searchParams.get('priceMax')!) : undefined,
      availability: searchParams.get('availability') as 'available' | 'under_offer' | 'all' || 'all'
    };

    // Clustering configuration
    const clustering = {
      enabled: searchParams.get('clustering') !== 'false',
      minZoom: parseInt(searchParams.get('minZoom') || '10'),
      maxDistance: parseInt(searchParams.get('maxDistance') || '50')
    };

    // Query listings within bounds
    const listings = await db.query(mapListingsQuery, [
      bounds.west, bounds.south, bounds.east, bounds.north,
      filters.propertyType,
      filters.sizeMin,
      filters.sizeMax,
      filters.priceMin,
      filters.priceMax,
      filters.availability === 'all' ? null : filters.availability
    ]);

    // Apply clustering if enabled
    let clusters: MapCluster[] = [];
    if (clustering.enabled && listings.length > 10) {
      const clusterManager = new MapClusterManager();
      clusters = clusterManager.createClusters(
        listings,
        clustering.minZoom,
        clustering.maxDistance
      );
    }

    const response: MapListingResponse = {
      listings: listings.map(row => ({
        id: row.id,
        title: row.title,
        address: {
          street: row.street_address,
          city: row.city,
          postcode: row.postcode,
          coordinates: {
            lat: row.latitude,
            lng: row.longitude
          }
        },
        property: {
          type: row.property_type,
          size: row.size_sqft,
          sizeUnit: 'sqft',
          price: row.price_per_month,
          priceUnit: 'month',
          availability: row.availability_status,
          features: row.features || []
        },
        contact: {
          name: row.contact_name,
          email: row.contact_email,
          phone: row.contact_phone
        },
        updatedAt: row.updated_at,
        images: row.images || []
      })),
      clusters,
      totalCount: listings.length,
      hasMore: listings.length >= 200
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('Map listings API error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch map listings' },
      { status: 500 }
    );
  }
}
```

## Mobile Optimization Requirements

### Touch Target Guidelines:
- **Minimum touch target size**: 44x44px (iOS HIG standard)
- **Recommended spacing**: 8px minimum between interactive elements
- **Hit area extension**: Invisible padding around small visual elements
- **Gesture conflicts**: Prevent map pan/zoom conflicts with popup interactions

### Responsive Breakpoints:
```scss
// Mobile-first responsive design
$breakpoints: (
  mobile: 320px,
  mobile-large: 425px,
  tablet: 768px,
  desktop: 1024px,
  desktop-large: 1440px
);

@mixin mobile-only {
  @media (max-width: 767px) {
    @content;
  }
}

@mixin tablet-up {
  @media (min-width: 768px) {
    @content;
  }
}

@mixin desktop-up {
  @media (min-width: 1024px) {
    @content;
  }
}
```

### Performance Considerations:
- **Debounced interactions**: 300ms delay for search input, 150ms for map movement
- **Marker virtualization**: Only render markers in viewport + buffer zone
- **Image lazy loading**: Load popup images only when popup opens
- **Gesture optimization**: Use `touch-action: manipulation` to prevent zoom delays

## Accessibility Requirements (WCAG 2.1 AA)

### Keyboard Navigation:
```typescript
// Keyboard navigation implementation
const useMapKeyboardNavigation = (mapRef: RefObject<MapInstance>) => {
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (!mapRef.current) return;

      switch (event.key) {
        case 'ArrowUp':
          event.preventDefault();
          mapRef.current.panBy(0, -50);
          break;
        case 'ArrowDown':
          event.preventDefault();
          mapRef.current.panBy(0, 50);
          break;
        case 'ArrowLeft':
          event.preventDefault();
          mapRef.current.panBy(-50, 0);
          break;
        case 'ArrowRight':
          event.preventDefault();
          mapRef.current.panBy(50, 0);
          break;
        case '+':
        case '=':
          event.preventDefault();
          mapRef.current.zoomIn();
          break;
        case '-':
          event.preventDefault();
          mapRef.current.zoomOut();
          break;
        case 'Escape':
          event.preventDefault();
          // Close any open popups
          break;
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [mapRef]);
};
```

### ARIA Implementation:
```tsx
// Accessible map marker component
const MapMarker = ({ listing, isSelected, onClick }: MapMarkerProps) => {
  return (
    <button
      className="map-marker"
      onClick={onClick}
      aria-label={`Property listing: ${listing.title} at ${listing.address.street}, ${listing.property.type}, ${listing.property.size} sqft, £${listing.property.price} per month`}
      aria-pressed={isSelected}
      aria-describedby={`marker-details-${listing.id}`}
      role="button"
      tabIndex={0}
    >
      <span className="map-marker__icon" aria-hidden="true">
        <BuildingIcon />
      </span>
      {listing.count && (
        <span 
          className="map-marker__count-badge"
          aria-label={`${listing.count} listings at this location`}
        >
          {listing.count}
        </span>
      )}
      <div 
        id={`marker-details-${listing.id}`}
        className="sr-only"
      >
        Last updated {formatDate(listing.updatedAt)}
        Status: {listing.property.availability}
        Contact: {listing.contact.name}
      </div>
    </button>
  );
};

// Accessible popup component
const MapPopup = ({ listings, onClose }: MapPopupProps) => {
  const headingId = useId();
  
  return (
    <div
      className="map-popup"
      role="dialog"
      aria-labelledby={headingId}
      aria-modal="true"
    >
      <div className="map-popup__header">
        <h2 id={headingId} className="map-popup__header-title">
          {listings.length > 1 
            ? `${listings.length} Properties at this Location`
            : listings[0].title
          }
        </h2>
        <button
          className="map-popup__close"
          onClick={onClose}
          aria-label="Close property details"
        >
          <CloseIcon aria-hidden="true" />
        </button>
      </div>
      {/* Popup content */}
    </div>
  );
};
```

### Screen Reader Support:
```typescript
// Live region announcements
const useMapAnnouncements = () => {
  const announce = (message: string, priority: 'polite' | 'assertive' = 'polite') => {
    const announcement = document.createElement('div');
    announcement.setAttribute('aria-live', priority);
    announcement.setAttribute('aria-atomic', 'true');
    announcement.className = 'sr-only';
    announcement.textContent = message;
    
    document.body.appendChild(announcement);
    
    setTimeout(() => {
      document.body.removeChild(announcement);
    }, 1000);
  };

  return { announce };
};

// Usage in map interactions
const handleMarkerClick = (listing: MapListing) => {
  announce(`Opened details for ${listing.title}`);
  setSelectedListing(listing);
};

const handleSearchComplete = (results: MapListing[]) => {
  announce(`Found ${results.length} properties in the selected area`);
};
```

## Implementation Tasks & Technical Guidance

### Task 1: Multi-Listing Clustering Implementation (AC1)
**Technical Implementation:**
- [ ] Enhance existing MapMarker component with count badges
- [ ] Implement clustering algorithm with configurable distance thresholds
- [ ] Add smooth zoom-based clustering transitions
- [ ] Create marker state management for selection and hover states
- [ ] Implement efficient re-clustering on map bounds changes
- [ ] Add visual hierarchy: single markers (violet), multi-markers (orange), selected (dark)
- [ ] Optimize clustering performance for large datasets (>1000 markers)
- [ ] Add accessibility features for clustered markers
- [ ] Implement touch-optimized sizing for mobile devices

### Task 2: Multi-Select Popup Architecture (AC2)
**Technical Implementation:**
- [ ] Design responsive popup component with mobile-first approach
- [ ] Implement list virtualization for popups with many listings
- [ ] Add bulk selection state management with React Context
- [ ] Create individual listing cards with consistent data display
- [ ] Implement smooth popup animations and positioning
- [ ] Add touch gesture support for mobile popup interactions
- [ ] Create accessible keyboard navigation within popups
- [ ] Implement "Select All" / "Deselect All" functionality
- [ ] Add bulk action buttons (Contact All, Save All, Compare)
- [ ] Optimize popup positioning to avoid viewport obstruction

### Task 3: Real Database Integration (AC3)
**Technical Implementation:**
- [ ] Enhance existing API endpoints for spatial queries
- [ ] Implement PostgreSQL spatial indexing for performance
- [ ] Add real-time data synchronization with WebSocket connections
- [ ] Create comprehensive error handling for database failures
- [ ] Implement data caching strategy with Redis for frequently accessed areas
- [ ] Add data validation and sanitization for incoming listing data
- [ ] Create database migration scripts for new spatial indexes
- [ ] Implement optimistic updates for real-time user interactions
- [ ] Add comprehensive logging for query performance monitoring
- [ ] Create fallback mechanisms for database unavailability

### Task 4: Location Search Integration (AC4)
**Technical Implementation:**
- [ ] Integrate geocoding service (Google Maps Geocoding API)
- [ ] Implement search autocomplete with debounced API calls
- [ ] Add URL state synchronization for shareable map links
- [ ] Create location suggestion ranking algorithm
- [ ] Implement search history and recent locations
- [ ] Add map viewport updates based on search results
- [ ] Create search result highlighting with boundary overlays
- [ ] Implement error handling for invalid or not-found locations
- [ ] Add analytics tracking for search usage patterns
- [ ] Create search result caching for improved performance

### Task 5: Mobile Touch Optimization (AC5)
**Technical Implementation:**
- [ ] Implement touch gesture handling with proper event delegation
- [ ] Create mobile-specific popup positioning algorithms
- [ ] Add swipe gestures for popup navigation and dismissal
- [ ] Implement responsive sizing with CSS clamp() for fluid scaling
- [ ] Create touch-friendly zoom controls with proper hit targets
- [ ] Add haptic feedback for supported devices
- [ ] Implement scroll lock when popups are open
- [ ] Create mobile-specific loading states and skeleton screens
- [ ] Add orientation change handling for landscape/portrait modes
- [ ] Optimize animation performance for mobile CPUs

### Task 6: Performance and Caching Architecture (AC6)
**Technical Implementation:**
- [ ] Implement marker virtualization using React Window
- [ ] Create intelligent data prefetching based on user behavior
- [ ] Add service worker caching for map tiles and static assets
- [ ] Implement request deduplication for concurrent API calls
- [ ] Create memory-efficient state management with proper cleanup
- [ ] Add performance monitoring with Core Web Vitals tracking
- [ ] Implement progressive image loading for listing photos
- [ ] Create efficient clustering algorithms with O(n log n) complexity
- [ ] Add background data synchronization for offline capability
- [ ] Implement lazy loading for non-critical map features

### Task 7: Accessibility and Screen Reader Support (AC1-6)
**Technical Implementation:**
- [ ] Implement comprehensive ARIA labeling for all interactive elements
- [ ] Create keyboard navigation patterns following WAI-ARIA best practices
- [ ] Add screen reader announcements for dynamic content changes
- [ ] Implement focus management for popup and modal interactions
- [ ] Create high contrast mode support with CSS custom properties
- [ ] Add reduced motion preferences handling
- [ ] Implement proper heading hierarchy and landmark regions
- [ ] Create alternative text generation for dynamic map content
- [ ] Add voice navigation support for modern assistive technologies
- [ ] Implement comprehensive accessibility testing automation

### Task 8: Testing and Quality Assurance
**Technical Implementation:**
- [ ] Create comprehensive unit tests for clustering algorithms
- [ ] Implement integration tests for API endpoint functionality
- [ ] Add visual regression tests for map component rendering
- [ ] Create performance benchmarks for large dataset handling
- [ ] Implement accessibility testing with automated tools
- [ ] Add cross-browser compatibility testing suite
- [ ] Create mobile device testing protocols
- [ ] Implement load testing for concurrent user scenarios
- [ ] Add error boundary testing for graceful failure handling
- [ ] Create user acceptance testing scenarios

## Performance Requirements

### Loading Performance Targets:
- **Initial Map Load**: < 3 seconds to first meaningful paint
- **Marker Rendering**: < 500ms for up to 200 markers
- **Popup Opening**: < 150ms transition time
- **Search Results**: < 1 second from query to results display
- **Database Queries**: < 100ms average response time for spatial queries

### Memory Management:
- **Marker Virtualization**: Render only visible markers + 20% buffer
- **Image Optimization**: WebP format with AVIF fallback, lazy loading
- **State Cleanup**: Proper component unmounting and event listener removal
- **Cache Limits**: Maximum 50MB map tile cache, 10MB listing data cache

### Network Optimization:
```typescript
// Efficient API call management
class MapDataManager {
  private cache = new Map<string, CacheEntry>();
  private pendingRequests = new Map<string, Promise<any>>();
  private readonly maxCacheSize = 100;
  private readonly cacheExpiry = 5 * 60 * 1000; // 5 minutes

  async fetchListings(bounds: MapBounds, filters: PropertyFilters): Promise<MapListing[]> {
    const cacheKey = this.generateCacheKey(bounds, filters);
    
    // Check cache first
    const cached = this.cache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheExpiry) {
      return cached.data;
    }

    // Check for pending request
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey)!;
    }

    // Create new request
    const request = this.performAPICall(bounds, filters)
      .then(data => {
        this.cache.set(cacheKey, {
          data,
          timestamp: Date.now()
        });
        this.pendingRequests.delete(cacheKey);
        this.enforceMaxCacheSize();
        return data;
      })
      .catch(error => {
        this.pendingRequests.delete(cacheKey);
        throw error;
      });

    this.pendingRequests.set(cacheKey, request);
    return request;
  }

  private enforceMaxCacheSize() {
    if (this.cache.size > this.maxCacheSize) {
      const oldestKey = Array.from(this.cache.keys())[0];
      this.cache.delete(oldestKey);
    }
  }

  private generateCacheKey(bounds: MapBounds, filters: PropertyFilters): string {
    return `${bounds.north},${bounds.south},${bounds.east},${bounds.west}|${JSON.stringify(filters)}`;
  }
}
```

## Definition of Done

### Functional Requirements:
- [ ] All acceptance criteria implemented and verified
- [ ] Multi-listing clustering working with count badges
- [ ] Popup interface handles multiple listings efficiently
- [ ] Real database integration displaying current listings
- [ ] Location search navigates map to searched areas
- [ ] Mobile touch targets meet accessibility standards (44x44px minimum)
- [ ] Cross-browser compatibility verified (Chrome, Firefox, Safari, Edge)

### Technical Quality:
- [ ] Code review completed with team approval
- [ ] Unit test coverage >85% for new components
- [ ] Integration tests passing for API endpoints
- [ ] Performance benchmarks met for all target metrics
- [ ] TypeScript strict mode compliance with no errors
- [ ] ESLint and Prettier formatting applied consistently
- [ ] Bundle size impact within acceptable limits (<100KB additional)

### Accessibility Compliance (WCAG 2.1 AA):
- [ ] Screen reader testing completed successfully
- [ ] Keyboard navigation functional for all interactions
- [ ] Color contrast ratios verified (4.5:1 minimum)
- [ ] Focus indicators visible and consistent
- [ ] ARIA labels implemented correctly
- [ ] Reduced motion preferences respected
- [ ] Semantic HTML structure validated

### Mobile Optimization:
- [ ] Touch targets minimum 44x44px verified
- [ ] Gesture interactions working smoothly
- [ ] Popup positioning optimized for mobile screens
- [ ] Loading states appropriate for mobile networks
- [ ] Performance acceptable on mid-range devices
- [ ] Battery usage optimized for mobile browsers

### Performance Verification:
- [ ] Core Web Vitals targets achieved (LCP <2.5s, FID <100ms, CLS <0.1)
- [ ] Database query performance optimized (<100ms average)
- [ ] Image loading optimized with lazy loading
- [ ] Memory usage within acceptable limits
- [ ] Network requests minimized with proper caching
- [ ] Animation performance at 60fps on target devices

### Data Integration:
- [ ] Real listings displayed from production database
- [ ] Data accuracy verified with spot checking
- [ ] Real-time updates working correctly
- [ ] Error handling graceful for data failures
- [ ] Caching strategy implemented and tested
- [ ] Data validation preventing corrupt display

### Browser & Device Testing:
- [ ] Desktop browsers: Chrome, Firefox, Safari, Edge (latest 2 versions)
- [ ] Mobile browsers: iOS Safari, Android Chrome (latest versions)
- [ ] Tablet testing: iPad, Android tablets
- [ ] Touch device testing: Surface Pro, touch laptops
- [ ] High-resolution display testing: Retina, 4K monitors
- [ ] Network condition testing: 3G, WiFi, offline scenarios

### Security & Privacy:
- [ ] Location data handling compliant with privacy regulations
- [ ] API endpoints secured against common vulnerabilities
- [ ] User interaction data anonymized appropriately
- [ ] External service integrations secure (geocoding APIs)
- [ ] Error messages don't expose sensitive information

## Future Enhancements

### Phase 2 Considerations:
- [ ] Heat map visualization for property density
- [ ] Advanced filtering with dynamic price ranges
- [ ] Saved searches with email notifications
- [ ] Property comparison tools integrated with map
- [ ] Street view integration for property locations
- [ ] Public transport layer for accessibility analysis
- [ ] Market trend overlays (price changes, availability patterns)

### Advanced Features:
- [ ] Machine learning-based property recommendations
- [ ] Predictive clustering based on user behavior
- [ ] Integration with CRM systems for landlord management
- [ ] Virtual reality property tours triggered from map
- [ ] Augmented reality property information overlays

---

## Dev Agent Record

### Implementation Tasks:
- [ ] Task 1: Multi-Listing Clustering Implementation (AC1)
- [ ] Task 2: Multi-Select Popup Architecture (AC2)
- [ ] Task 3: Real Database Integration (AC3)
- [ ] Task 4: Location Search Integration (AC4)
- [ ] Task 5: Mobile Touch Optimization (AC5)
- [ ] Task 6: Performance and Caching Architecture (AC6)
- [ ] Task 7: Accessibility and Screen Reader Support
- [ ] Task 8: Testing and Quality Assurance

### Debug Log:
| Task | File | Change | Reverted? |
|------|------|--------|-----------|
| | | | |

### Completion Notes:
*Implementation deviations and notes will be documented here*

### Change Log:
*Requirement changes during implementation will be tracked here*

### File List:
*All created/modified files will be tracked here*

---

*This story represents a significant enhancement to the map functionality, providing users with efficient multi-listing interaction, real data integration, and optimized mobile experience for improved property discovery and engagement.*