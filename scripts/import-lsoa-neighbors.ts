/**
 * Import LSOA neighbor relationships into Supabase
 * Reads from CSV file generated by Python spatial analysis
 */

import fs from 'fs';
import path from 'path';
import { createClient } from '@supabase/supabase-js';
import { parse } from 'csv-parse/sync';
import dotenv from 'dotenv';

// Load environment variables from apps/web/.env.local
dotenv.config({ path: path.join(process.cwd(), 'apps', 'web', '.env.local') });

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!supabaseUrl || !supabaseKey) {
  console.error('‚ùå Missing Supabase credentials');
  console.error('Required: NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY');
  process.exit(1);
}

const supabase = createClient(supabaseUrl, supabaseKey);

async function importNeighbors() {
  console.log('üîç Loading LSOA neighbors CSV...');

  const csvPath = path.join(
    process.cwd(),
    'apps',
    'web',
    'data',
    'census2021',
    'lsoa_neighbors.csv'
  );

  if (!fs.existsSync(csvPath)) {
    console.error(`‚ùå CSV file not found: ${csvPath}`);
    process.exit(1);
  }

  const csvContent = fs.readFileSync(csvPath, 'utf-8');
  const records = parse(csvContent, {
    columns: true,
    skip_empty_lines: true,
  });

  console.log(`üìä Found ${records.length} neighbor relationships`);

  // Clear existing data
  console.log('üóëÔ∏è  Clearing existing data...');
  const { error: deleteError } = await supabase.from('lsoa_neighbors').delete().neq('id', 0);

  if (deleteError) {
    console.error('‚ùå Error clearing table:', deleteError);
    process.exit(1);
  }

  // Insert in batches of 1000
  const BATCH_SIZE = 1000;
  let inserted = 0;

  for (let i = 0; i < records.length; i += BATCH_SIZE) {
    const batch = records.slice(i, i + BATCH_SIZE);
    const insertData = batch.map((record: any) => ({
      lsoa_code: record.lsoa,
      neighbor_code: record.neighbor,
    }));

    const { error } = await supabase.from('lsoa_neighbors').insert(insertData);

    if (error) {
      console.error(`‚ùå Error inserting batch at index ${i}:`, error);
      process.exit(1);
    }

    inserted += batch.length;
    const progress = ((inserted / records.length) * 100).toFixed(1);
    process.stdout.write(`\r‚è≥ Importing: ${inserted}/${records.length} (${progress}%)`);
  }

  console.log('\n‚úÖ Import complete!');
  console.log(`   Total relationships: ${inserted}`);

  // Verify import
  const { count, error: countError } = await supabase
    .from('lsoa_neighbors')
    .select('*', { count: 'exact', head: true });

  if (countError) {
    console.error('‚ùå Error verifying import:', countError);
  } else {
    console.log(`   Verified count: ${count}`);
  }

  // Test query
  console.log('\nüß™ Testing query for E01000001...');
  const { data, error: queryError } = await supabase
    .from('lsoa_neighbors')
    .select('neighbor_code')
    .eq('lsoa_code', 'E01000001');

  if (queryError) {
    console.error('‚ùå Error testing query:', queryError);
  } else {
    console.log(`   Found ${data?.length} neighbors`);
    console.log(`   Neighbors: ${data?.map((d) => d.neighbor_code).join(', ')}`);
  }
}

importNeighbors().catch((error) => {
  console.error('‚ùå Fatal error:', error);
  process.exit(1);
});
